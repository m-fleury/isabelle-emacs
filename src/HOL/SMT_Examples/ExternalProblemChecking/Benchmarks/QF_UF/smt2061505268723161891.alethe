unsat
(assume a0 circuit)
(assume a1 rd2)
(assume a2 red_MR)
(assume a3 (or grn_SR org_SR))
(assume a4 (=> grn (and (! (not org) :named @p_3) (! (not rd1) :named @p_2) (! (not rd2) :named @p_1))))
(assume a5 (! (=> org (! (and @p_2 @p_1) :named @p_4)) :named @p_5))
(assume a6 (! (=> rd1 @p_1) :named @p_6))
(assume a7 (= org_MR org))
(assume a8 (= grn_SR rd1))
(assume a9 (= org_SR rd2))
(assume a10 (= red_SR (or grn org)))
(assume a11 (! (not (= rd1 (! (or org (! (and prt rd1) :named @p_7)) :named @p_8))) :named @p_9))
(step t0 (cl rd1 @p_8) :rule not_equiv1 :premises (a11))
(step t1 (cl @p_2 @p_1) :rule implies :premises (a6))
(step t2 (cl @p_2) :rule resolution :premises (t1 a1))
(step t3 (cl @p_8) :rule resolution :premises (t0 t2))
(step t4 (cl (! (not @p_8) :named @p_10) org @p_7) :rule or_pos)
(step t5 (cl @p_3 @p_4) :rule implies :premises (a5))
(step t6 (cl (! (not @p_4) :named @p_12) @p_1) :rule and_pos)
(step t7 (cl @p_12) :rule resolution :premises (t6 a1))
(step t8 (cl @p_3) :rule resolution :premises (t5 t7))
(step t9 (cl (! (not @p_7) :named @p_11) rd1) :rule and_pos)
(step t10 (cl @p_11) :rule resolution :premises (t9 t2))
(step t11 (cl @p_10) :rule resolution :premises (t4 t8 t10))
(step t12 (cl) :rule resolution :premises (t3 t11))
