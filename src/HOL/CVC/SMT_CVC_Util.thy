theory SMT_CVC_Util
  imports Smtlib_String
begin

(*XOR: Does not appear in the SMT-Problem but is generated by cvc5 in some bit-blasting steps.*)

definition xor :: "bool \<Rightarrow> bool \<Rightarrow> bool" (infixl "[+]" 60)
  where "A [+] B \<equiv> (\<not>(A = B))"

lemma xor1:
  "A [+] B \<Longrightarrow> A \<or> B"
  unfolding xor_def
  by auto

lemma xor2:
  "A [+] B \<Longrightarrow> \<not>A \<or> \<not>B"
  unfolding xor_def
  by auto

lemma not_xor1:
  "\<not>(A [+] B) \<Longrightarrow> A \<or> \<not>B"
  unfolding xor_def
  by auto

lemma not_xor2:
  "\<not>(A [+] B) \<Longrightarrow> \<not>A \<or> B"
  unfolding xor_def
  by auto

lemma xor_pos1:
  "\<not>(A [+] B) \<or> A \<or> B"
  unfolding xor_def
  by auto

lemma xor_pos2:
  "\<not>(A [+] B) \<or> \<not>A \<or> \<not>B"
  unfolding xor_def
  by auto

lemma xor_neg1:
  "(A [+] B) \<or> A \<or> \<not>B"
  unfolding xor_def
  by auto

lemma xor_neg2:
  "(A [+] B) \<or> \<not>A \<or> B"
  unfolding xor_def
  by auto

lemma xor_simps [simp]: 
  "(A [+] False) = A"
  "(False [+] A) = A"
  "(A [+] True) = (\<not>A)"
  "(True [+] A) = (\<not>A)"
  unfolding xor_def
  by auto

end
